import { supabase } from './db/supabase';
import { drawRandomCard, generateDeceased, CardType } from './gameCards';
import { v4 as uuidv4 } from 'uuid';

export interface Player {
  id: string;
  name: string;
  is_host: boolean;
  is_estate_keeper: boolean;
  is_ready: boolean;
  score: number;
  cards: {
    identity?: string;
    relationship?: string;
    backstory: string[];
  };
}

export interface GameState {
  id: string;
  game_code: string;
  status: 'waiting' | 'setup' | 'playing' | 'finished';
  host_id: string | null;
  estate_keeper_id: string | null;
  current_round: number;
  max_rounds: number;
  current_player_turn: number;
  deceased_name: string | null;
  deceased_identity: string | null;
  deceased_estate: string | null;
  game_settings?: { mode?: 'english' | 'desi' };
  players: Player[];
}

export async function createGame(hostName: string, gameMode: 'english' | 'desi' = 'english'): Promise<{ game: GameState; playerId: string } | null> {
  try {
    const playerId = uuidv4();
    const isDesi = gameMode === 'desi';
    
    // Create the game
    const { data: gameData, error: gameError } = await supabase
      .from('games')
      .insert({
        host_id: playerId,
        status: 'waiting',
        game_code: '', // Will be generated by trigger
        game_settings: { mode: gameMode }
      })
      .select()
      .single();

    if (gameError) throw gameError;

    // Add the host as a player
    const { error: playerError } = await supabase
      .from('players')
      .insert({
        id: playerId,
        game_id: gameData.id,
        name: hostName,
        is_host: true
      });

    if (playerError) throw playerError;

    // Initialize card decks (we'll keep cards in memory for faster access)
    const deceased = generateDeceased(isDesi);
    
    const { error: updateError } = await supabase
      .from('games')
      .update({
        deceased_name: deceased.name,
        deceased_identity: deceased.identity,
        deceased_estate: deceased.estate
      })
      .eq('id', gameData.id);

    if (updateError) throw updateError;

    return {
      game: {
        ...gameData,
        status: (gameData.status || 'waiting') as 'waiting' | 'setup' | 'playing' | 'finished',
        current_round: gameData.current_round || 1,
        max_rounds: gameData.max_rounds || 3,
        current_player_turn: (gameData as any).current_player_turn || 0,
        deceased_name: deceased.name,
        deceased_identity: deceased.identity,
        deceased_estate: deceased.estate,
        game_settings: (gameData.game_settings as { mode?: 'english' | 'desi' }) || { mode: gameMode },
        players: [{
          id: playerId,
          name: hostName,
          is_host: true,
          is_estate_keeper: false,
          is_ready: false,
          score: 0,
          cards: { backstory: [] }
        }]
      },
      playerId
    };
  } catch (error) {
    console.error('Error creating game:', error);
    return null;
  }
}

export async function joinGame(gameCode: string, playerName: string): Promise<{ game: GameState; playerId: string } | null> {
  try {
    const playerId = uuidv4();

    // First check if game exists and is joinable
    const { data: gameData, error: gameError } = await supabase
      .from('games')
      .select('*')
      .eq('game_code', gameCode.toUpperCase())
      .single();

    if (gameError || !gameData) {
      throw new Error('Game not found');
    }

    if (gameData.status !== 'waiting') {
      throw new Error('Game is not accepting new players');
    }

    // Check player count
    const { data: existingPlayers } = await supabase
      .from('players')
      .select('*')
      .eq('game_id', gameData.id);

    if (existingPlayers && existingPlayers.length >= 12) {
      throw new Error('Game is full');
    }

    // Add player to game
    const { error: playerError } = await supabase
      .from('players')
      .insert({
        id: playerId,
        game_id: gameData.id,
        name: playerName,
        is_host: false
      });

    if (playerError) throw playerError;

    // Emit player joined event
    await supabase
      .from('game_events')
      .insert({
        game_id: gameData.id,
        event_type: 'player_joined',
        event_data: { player_name: playerName },
        created_by: playerId
      });

    return await getGameState(gameData.id, playerId);
  } catch (error) {
    console.error('Error joining game:', error);
    return null;
  }
}

export async function getGameState(gameId: string, playerId?: string): Promise<{ game: GameState; playerId: string } | null> {
  try {
    const { data: gameData, error: gameError } = await supabase
      .from('games')
      .select('*')
      .eq('id', gameId)
      .single();

    if (gameError) throw gameError;

    const { data: playersData, error: playersError } = await supabase
      .from('players')
      .select('*')
      .eq('game_id', gameId)
      .order('joined_at');

    if (playersError) throw playersError;

    const players: Player[] = playersData.map(p => ({
      id: p.id,
      name: p.name,
      is_host: p.is_host || false,
      is_estate_keeper: p.is_estate_keeper || false,
      is_ready: p.is_ready || false,
      score: p.score || 0,
      cards: (p.cards as any) || { backstory: [] }
    }));

    return {
      game: {
        ...gameData,
        status: (gameData.status || 'waiting') as 'waiting' | 'setup' | 'playing' | 'finished',
        current_round: gameData.current_round || 1,
        max_rounds: gameData.max_rounds || 3,
        current_player_turn: (gameData as any).current_player_turn || 0,
        game_settings: (gameData.game_settings as { mode?: 'english' | 'desi' }) || { mode: 'english' },
        players
      },
      playerId: playerId || players[0]?.id || ''
    };
  } catch (error) {
    console.error('Error getting game state:', error);
    return null;
  }
}

export async function setEstateKeeper(gameId: string, hostId: string, estateKeeperId: string): Promise<boolean> {
  try {
    // Verify the requester is the host
    const { data: hostData } = await supabase
      .from('players')
      .select('is_host')
      .eq('id', hostId)
      .eq('game_id', gameId)
      .single();

    if (!hostData?.is_host) {
      throw new Error('Only the host can set the estate keeper');
    }

    // Remove estate keeper status from all players
    await supabase
      .from('players')
      .update({ is_estate_keeper: false })
      .eq('game_id', gameId);

    // Set the new estate keeper
    const { error } = await supabase
      .from('players')
      .update({ is_estate_keeper: true })
      .eq('id', estateKeeperId)
      .eq('game_id', gameId);

    if (error) throw error;

    // Update game table
    await supabase
      .from('games')
      .update({ estate_keeper_id: estateKeeperId })
      .eq('id', gameId);

    // Emit event
    await supabase
      .from('game_events')
      .insert({
        game_id: gameId,
        event_type: 'estate_keeper_set',
        event_data: { estate_keeper_id: estateKeeperId },
        created_by: hostId
      });

    return true;
  } catch (error) {
    console.error('Error setting estate keeper:', error);
    return false;
  }
}

export async function dealCards(gameId: string, estateKeeperId: string): Promise<boolean> {
  try {
    // Verify the requester is the estate keeper
    const { data: estateKeeperData } = await supabase
      .from('players')
      .select('is_estate_keeper')
      .eq('id', estateKeeperId)
      .eq('game_id', gameId)
      .single();

    if (!estateKeeperData?.is_estate_keeper) {
      throw new Error('Only the estate keeper can deal cards');
    }

    // Get game settings to determine card mode
    const { data: gameData } = await supabase
      .from('games')
      .select('game_settings')
      .eq('id', gameId)
      .single();

    const isDesi = (gameData?.game_settings as { mode?: 'english' | 'desi' })?.mode === 'desi';

    // Get all players to check minimum count
    const { data: allPlayersData } = await supabase
      .from('players')
      .select('*')
      .eq('game_id', gameId);

    if (!allPlayersData) throw new Error('No players found');

    // Check minimum player count (must have at least 3 players total including estate keeper)
    if (allPlayersData.length < 3) {
      throw new Error('Need at least 3 players to start the game');
    }

    // Get players to deal cards to (excluding estate keeper)
    const playersData = allPlayersData.filter(p => !p.is_estate_keeper);

    const usedCards: Record<CardType, string[]> = {
      identity: [],
      relationship: [],
      backstory: [],
      objection: []
    };

    // Deal cards to each player
    for (const player of playersData) {
      const identity = drawRandomCard('identity', usedCards.identity, isDesi);
      usedCards.identity.push(identity);

      const relationship = drawRandomCard('relationship', usedCards.relationship, isDesi);
      usedCards.relationship.push(relationship);

      const backstory1 = drawRandomCard('backstory', usedCards.backstory, isDesi);
      usedCards.backstory.push(backstory1);

      const backstory2 = drawRandomCard('backstory', usedCards.backstory, isDesi);
      usedCards.backstory.push(backstory2);

      const cards = {
        identity,
        relationship,
        backstory: [backstory1, backstory2]
      };

      await supabase
        .from('players')
        .update({ cards })
        .eq('id', player.id);
    }

    // Update game status
    await supabase
      .from('games')
      .update({ status: 'playing' })
      .eq('id', gameId);

    // Emit event
    await supabase
      .from('game_events')
      .insert({
        game_id: gameId,
        event_type: 'cards_dealt',
        event_data: {},
        created_by: estateKeeperId
      });

    return true;
  } catch (error) {
    console.error('Error dealing cards:', error);
    return false;
  }
}

export async function updatePlayerScore(gameId: string, estateKeeperId: string, playerId: string, points: number): Promise<boolean> {
  try {
    console.log('üéØ updatePlayerScore called:', { gameId, estateKeeperId, playerId, points });
    
    // Verify the requester is the estate keeper
    const { data: estateKeeperData } = await supabase
      .from('players')
      .select('is_estate_keeper')
      .eq('id', estateKeeperId)
      .eq('game_id', gameId)
      .single();

    if (!estateKeeperData?.is_estate_keeper) {
      throw new Error('Only the estate keeper can update scores');
    }

    console.log('üéØ Updating player score in database...');
    const { error } = await supabase
      .from('players')
      .update({ score: points })
      .eq('id', playerId)
      .eq('game_id', gameId);

    if (error) {
      console.error('‚ùå Database update error:', error);
      throw error;
    }
    
    console.log('‚úÖ Player score updated in database');

    // Emit event
    console.log('üì¢ Emitting score_updated event...');
    const { error: eventError } = await supabase
      .from('game_events')
      .insert({
        game_id: gameId,
        event_type: 'score_updated',
        event_data: { player_id: playerId, points },
        created_by: estateKeeperId
      });

    if (eventError) {
      console.error('‚ùå Event emission error:', eventError);
      throw eventError;
    }
    
    console.log('‚úÖ score_updated event emitted successfully');
    return true;
  } catch (error) {
    console.error('‚ùå Error updating score:', error);
    return false;
  }
}

export async function drawCardForPlayer(gameId: string, estateKeeperId: string, playerId: string, cardType: CardType): Promise<string | null> {
  try {
    // Verify the requester is the estate keeper
    const { data: estateKeeperData } = await supabase
      .from('players')
      .select('is_estate_keeper')
      .eq('id', estateKeeperId)
      .eq('game_id', gameId)
      .single();

    if (!estateKeeperData?.is_estate_keeper) {
      throw new Error('Only the estate keeper can draw cards');
    }

    // Get game settings to determine card mode
    const { data: gameData } = await supabase
      .from('games')
      .select('game_settings')
      .eq('id', gameId)
      .single();

    const isDesi = (gameData?.game_settings as { mode?: 'english' | 'desi' })?.mode === 'desi';

    // Get the target player's current cards
    const { data: playerData } = await supabase
      .from('players')
      .select('cards')
      .eq('id', playerId)
      .eq('game_id', gameId)
      .single();

    if (!playerData) {
      throw new Error('Player not found');
    }

    // Get all used cards from all players to avoid duplicates
    const { data: allPlayers } = await supabase
      .from('players')
      .select('cards')
      .eq('game_id', gameId);

    const usedCards: string[] = [];
    allPlayers?.forEach(player => {
      if (player.cards && typeof player.cards === 'object' && player.cards !== null) {
        const cards = player.cards as any;
        if (cards.identity) usedCards.push(cards.identity);
        if (cards.relationship) usedCards.push(cards.relationship);
        if (cards.backstory && Array.isArray(cards.backstory)) {
          usedCards.push(...cards.backstory);
        }
        if (cards.objections && Array.isArray(cards.objections)) {
          usedCards.push(...cards.objections);
        }
      }
    });

    const newCard = drawRandomCard(cardType, usedCards, isDesi);

    // Update the player's cards
    const currentCards = (playerData.cards as any) || { backstory: [] };
    
    if (cardType === 'backstory') {
      currentCards.backstory = [...(currentCards.backstory || []), newCard];
    } else if (cardType === 'objection') {
      currentCards.objections = [...(currentCards.objections || []), newCard];
    } else {
      // For identity and relationship, replace if exists
      currentCards[cardType] = newCard;
    }

    // Update the player's cards in the database
    await supabase
      .from('players')
      .update({ cards: currentCards })
      .eq('id', playerId)
      .eq('game_id', gameId);

    // Emit event with the new card
    await supabase
      .from('game_events')
      .insert({
        game_id: gameId,
        event_type: 'card_drawn',
        event_data: { player_id: playerId, card_type: cardType, card: newCard },
        created_by: estateKeeperId
      });

    return newCard;
  } catch (error) {
    console.error('Error drawing card:', error);
    return null;
  }
}

export async function nextTurn(gameId: string, estateKeeperId: string): Promise<boolean> {
  try {
    // Verify the requester is the estate keeper
    const { data: estateKeeperData } = await supabase
      .from('players')
      .select('is_estate_keeper')
      .eq('id', estateKeeperId)
      .eq('game_id', gameId)
      .single();

    if (!estateKeeperData?.is_estate_keeper) {
      throw new Error('Only the estate keeper can advance turns');
    }

    // Get current game state
    const { data: gameData } = await supabase
      .from('games')
      .select('current_player_turn, current_round, max_rounds')
      .eq('id', gameId)
      .single();

    if (!gameData) {
      throw new Error('Game not found');
    }

    // Get player count (excluding estate keeper)
    const { data: playersData } = await supabase
      .from('players')
      .select('id, is_estate_keeper')
      .eq('game_id', gameId);

    if (!playersData) {
      throw new Error('No players found');
    }

    const nonEstateKeeperPlayers = playersData.filter(p => !p.is_estate_keeper);
    const currentTurn = gameData.current_player_turn || 0;
    const currentRound = gameData.current_round || 1;
    const maxRounds = gameData.max_rounds || 3;

    let newTurn = currentTurn + 1;
    let newRound = currentRound;

    // If we've gone through all players, start next round
    if (newTurn >= nonEstateKeeperPlayers.length) {
      newTurn = 0;
      newRound = currentRound + 1;
    }

    // Check if game should end
    if (newRound > maxRounds) {
      await supabase
        .from('games')
        .update({ status: 'finished' })
        .eq('id', gameId);

      await supabase
        .from('game_events')
        .insert({
          game_id: gameId,
          event_type: 'game_finished',
          event_data: {},
          created_by: estateKeeperId
        });

      return true;
    }

    // Update game state
    await supabase
      .from('games')
      .update({ 
        current_player_turn: newTurn,
        current_round: newRound
      })
      .eq('id', gameId);

    // Emit event
    await supabase
      .from('game_events')
      .insert({
        game_id: gameId,
        event_type: 'turn_advanced',
        event_data: { 
          new_turn: newTurn, 
          new_round: newRound,
          current_player_id: nonEstateKeeperPlayers[newTurn]?.id
        },
        created_by: estateKeeperId
      });

    return true;
  } catch (error) {
    console.error('Error advancing turn:', error);
    return false;
  }
}

export async function endPlayerTurn(gameId: string, playerId: string): Promise<boolean> {
  try {
    // For now, just emit the event - we'll let the estate keeper manage turns
    // This allows players to signal they're ready for the next turn

    // Emit event that player is ready for next turn
    await supabase
      .from('game_events')
      .insert({
        game_id: gameId,
        event_type: 'player_turn_ended',
        event_data: { player_id: playerId },
        created_by: playerId
      });

    return true;
  } catch (error) {
    console.error('Error ending turn:', error);
    return false;
  }
}

export function subscribeToGameEvents(gameId: string, callback: (event: any) => void) {
  console.log('üöÄ Setting up subscription for game:', gameId);
  
  // Create a unique channel name
  const channelName = `game-updates-${gameId}-${Date.now()}`;
  const channel = supabase.channel(channelName);
  
  console.log('üì° Channel created:', channelName);
  
  return channel
    .on('postgres_changes', 
      { 
        event: '*', 
        schema: 'public', 
        table: 'game_events',
        filter: `game_id=eq.${gameId}`
      }, 
      (payload) => {
        console.log('üì¢ Game event received:', payload);
        callback(payload);
      }
    )
    .on('postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'players',
        filter: `game_id=eq.${gameId}`
      },
      (payload) => {
        console.log('üë• Player event received:', payload);
        callback(payload);
      }
    )
    .on('postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'games',
        filter: `id=eq.${gameId}`
      },
      (payload) => {
        console.log('üé≤ Game state event received:', payload);
        callback(payload);
      }
    )
    .subscribe((status, err) => {
      console.log('üì° Subscription status:', status);
      if (err) {
        console.error('üí• Subscription error:', err);
      }
      if (status === 'SUBSCRIBED') {
        console.log(`‚úÖ Successfully subscribed to game ${gameId} updates`);
      } else if (status === 'CLOSED') {
        console.log(`‚ùå Subscription to game ${gameId} closed`);
      } else if (status === 'CHANNEL_ERROR') {
        console.error(`üí• Subscription error for game ${gameId}`);
      }
    });
} 
